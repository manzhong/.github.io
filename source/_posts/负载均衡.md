---
title: 负载均衡
tags:
  - Web
categories:
  - Web
encrypt: 
enc_pwd: 
abbrlink: 15860
date: 2018-07-15 21:36:12
summary_img:
---

# 一 网络

**浏览器端口数 65535**  网页服务器端口固定80

linux 命令  netstat  -natp   查看端口IP占用情况   n把ip转为逻辑名称   a 是所有  p 是打印

TCP/IP协议  OSI七层模型

**1  应用层**  7 NGINX七层  (是封装的协议 若做具体的事  一层一层向下 然后一层一层的阻塞)  分层意义解耦

http   SMTP   ssh  

**2  表示层**6

**3  会话层**5

**4  传输控制层**4 (只是控制但不管 数据的发送)   lvs  四层 内核    	TCP	三次握手   > 传输数据  >  四次分手  这个过程是基于 IP :prot  到 IP: prot的 具有唯一性

```
为什么有三次握手   A 客户端  B 服务器
流程 A向B 发送连接包(sync) 
B 收到 后 向A 发送 我已收到连接(sync+ack)
A 收到后  向B 发送确认包 (ack)           因为连接是双向的 若是两次 只有A 能确认 我发出去的B一定能接到 而 B 只是确定我发出去了 但不确定 A 收到没有  所以有了第三次

四次分手
客户端 向服务器发送 断开连接(fin)  服务器收到后 回复确认(只是一个确认 不是我也想断开)  
然后服务器又再去向客户端发送  断开连接(fin)  客户端收到后 回复 确认
因为断开 必须 双方都同意才能断开

若是两台服务器b,c 三次握手    a向b 发送  连接  b回复 然后 a向c 发送确认 则B 服务器则会一直等待 会出问题
```



tcp (面向连接的可靠的协议)  udp (不可靠的不是面向连接的协议)   socket

**5  网络层** 3  IP   ICmp

linux上查看 路由表  route  -n    这个表是 网络层的核心

![img](/images/fzjh/ly.jpg)

````
若是ping  www.baidu.com   的包是哪个网卡发的   会拿着www.baidu.com解析的IP 与上表中的 子网掩码  一个一个按位与  余出来的值与Destination(网络号)  的值相同 则由这个 网卡发  最终基本都由 0.0.0.0  发   

所以0.0.0.0  很特殊  是一个默认网关的子网掩码和网络号  

````

````
tcp/ip 协议是基于一跳一跳(route)传输的  就是我只管发出 而不管 你下一个发给谁 只要最终到达目的地即可
如 三次握手 第一次我发出信息 会通过路由表 解析出谁发 就是找出路由出口 

如家里局域网上网 路由器就是下一跳  与路由器的距离就是吓一跳  所有发出的信息网关就是吓一跳
````



子网掩码  ip与子网掩码  按位与得到是网络号  

网关

三次握手的每一次发送 都会被这一层 阻塞

**6  链路层**2

以太网 Ethernet  : MAC (物理地址)

**ARP 协议   地址解析协议**

有一个ARP表    **linux 查看  arp -a**  

![img](/images/fzjh/arp.jpg)

这个地址  是自己电脑的地址   at  物理地址

在ping  www.baidu.com  之后

![img](/images/fzjh/arp2.jpg)

会多出一个 网关地址 at  MAC 

```
当一个 计算机A想 请求另外一个节点的硬件地址的时候 他会封一个arp包 值是全F   发给路由器  路由器会把他的物理地址
学习  并把这个包进行广播  则目标节点 会把自己的物理地址 传给路由 路由把地址转发给A  最后路由也学了 两台不同的地址
```



**7  物理层**1



总结

最终七层过后这个信封要填满:

![img](/images/fzjh/xf.jpg)

```
应用层发 请求  被阻塞  因为传输控制层要建立连接   产生第一个发送的包 但不能发出去 因为网络层 要知道下一跳是谁
去路由表 找到下一跳 之后 但不知道 对方的MAC地址 所以来到链路层
```

**1整个互联网是建立在下一跳的模式下**

IP是逻辑的两个端点

Mac是物理上连接的两个节点

在每一跳的时候会修改源Mac地址  和目标Mac地址

**2端点间 tcp 传输过程**

确认机制

状态机制

不可分割   三次握手和  四次分手是不可分割的

**3 解析数据包是需要成本的**

交换机 两层  只关心Mac地址

​        学习机制

路由器   三层  只关心IP的路由表

LVS服务器    :   在四层   只关心PORT  ,状态   并不需要和客户端进行握手连接 他只需要拿到四层的状态取查看状态 快速转发出去即可  四层可以很快的进行负载  效率高  但是瞎子负载  不知道客户端请求的是啥  因为是基于包的  不是基于面向连接的  不能根据资源进行很好的负载

NGINX   :  七层  关心socket  对应关系   是必须先和客户端进行三次握手开辟资源之后才能做负载的   速度慢  但可以知道请求的是什么    可以做更好的资源转发



最终 可以四层  和七层联合使用    先使用 四层 承受大量的并发  在四层后面 放大量的七层  然后经七层  转发给不同的服务器   淘宝就是这样做的



# 二 LVS负载均衡

## 1 四层拓补图

![img](/images/fzjh/l1.jpg)

lvs不做三次握手和四次分手  他只是转发消息到其他的服务器  并且保证 三次握手和四次分手 都是针对同一个服务器

且当第一次 三四  和第二次三四   请求的资源是一样的   就是页面是一样的  (只针对静态资源)   就是lvs服务器后面的服务器都是镜像部署

**上网流程分析**

公网IP   如百度等   在互联网中是惟一的

私网IP    如局域网中的都是    私网IP发出的消息  是不会在公网IP中进行下一跳

```
路由器会有一个公网IP    比如局域网中 192.168.80.12:21214 发送请求到百度  在路由器(18.11.18.22)中 会将对这个用户产生一个端口 最终(18.11.18.22:223  192.168.80.12:21214)  去发送消息给百度  
这个过程是S_NET 地址转换  S_net  是修改源地址的IP  D_NET 是修改目标的IP地址
```

