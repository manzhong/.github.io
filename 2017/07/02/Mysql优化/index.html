<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":false,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一 mysql的大表优化 1 介绍 当mysql 的单表记录数过大时,增删查改性能都会急剧下降,(MySQL推荐单表的大小为1百万,经过优化可以承担千万级)  2 单表优化 二 mysql的索引 2.1 索引介绍 为何要有索引?   一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql优化">
<meta property="og:url" content="http://example.com/2017/07/02/Mysql%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="春雨里洗过的太阳">
<meta property="og:description" content="一 mysql的大表优化 1 介绍 当mysql 的单表记录数过大时,增删查改性能都会急剧下降,(MySQL推荐单表的大小为1百万,经过优化可以承担千万级)  2 单表优化 二 mysql的索引 2.1 索引介绍 为何要有索引?   一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153237166-685160297.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153244905-527142719.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153252502-161866485.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153422151-197456486.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153544678-142449703.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153549494-1076685599.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153554167-1437094022.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153600593-1903115087.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153609568-1535087839.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153619312-2087128773.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153630415-1707823376.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153635337-1400046793.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153639262-1394935042.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153643362-658190876.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153821683-965016448.png">
<meta property="article:published_time" content="2017-07-02T01:51:45.000Z">
<meta property="article:modified_time" content="2023-03-17T15:42:10.673Z">
<meta property="article:author" content="HF">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153237166-685160297.png">

<link rel="canonical" href="http://example.com/2017/07/02/Mysql%E4%BC%98%E5%8C%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector.css" />
  <title>Mysql优化 | 春雨里洗过的太阳</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">春雨里洗过的太阳</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">世间所有的相遇，都是久别重逢</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/02/Mysql%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hexo.jpg">
      <meta itemprop="name" content="HF">
      <meta itemprop="description" content="第二名就是头号输家">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="春雨里洗过的太阳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mysql优化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-02 09:51:45" itemprop="dateCreated datePublished" datetime="2017-07-02T09:51:45+08:00">2017-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-17 23:42:10" itemprop="dateModified" datetime="2023-03-17T23:42:10+08:00">2023-03-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一-mysql的大表优化"><a href="#一-mysql的大表优化" class="headerlink" title="一 mysql的大表优化"></a>一 mysql的大表优化</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>当mysql 的单表记录数过大时,增删查改性能都会急剧下降,(MySQL推荐单表的大小为1百万,经过优化可以承担千万级)</p>
<h2 id="2-单表优化"><a href="#2-单表优化" class="headerlink" title="2 单表优化"></a>2 单表优化</h2><h1 id="二-mysql的索引"><a href="#二-mysql的索引" class="headerlink" title="二 mysql的索引"></a>二 mysql的索引</h1><h2 id="2-1-索引介绍"><a href="#2-1-索引介绍" class="headerlink" title="2.1 索引介绍"></a>2.1 索引介绍</h2><p><strong>为何要有索引?</strong></p>
<p> 一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。</p>
<p><strong>什么是索引？</strong></p>
<p> 索引在MySQL中也叫做“键”或者”key”（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）<br>​ 索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。<br>​ 索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</p>
<p> 强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据</p>
<p><strong>你是否对索引存在误解？</strong></p>
<p> 索引是应用程序设计和开发的一个重要方面。若索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响，要找到一个平衡点，这对应用程序的性能至关重要。一些开发人员总是在事后才想起添加索引—-我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程之类，他们甚至可能不知道索引的存在，或认为事后让相关DBA加上即可。DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需的时间，并且可能会遗漏一部分的索引。当然索引也并不是越多越好，我曾经遇到过这样一个问题：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了太多的索引，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。</p>
<h2 id="2-2-索引的原理"><a href="#2-2-索引的原理" class="headerlink" title="2.2 索引的原理"></a>2.2 索引的原理</h2><h3 id="2-2-1-索引原理"><a href="#2-2-1-索引原理" class="headerlink" title="2.2.1 索引原理"></a>2.2.1 索引原理</h3><p> 索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等，下面内容看不懂的同学也没关系，能明白这个目录的道理就行了。 那么你想，书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。你再想，你在没有数据的情况下先建索引或者说目录快，还是已经存在好多的数据了，然后再去建索引，哪个快，肯定是没有数据的时候快，因为如果已经有了很多数据了，你再去根据这些数据建索引，是不是要将数据全部遍历一遍，然后根据数据建立索引。你再想，索引建立好之后再添加数据快，还是没有索引的时候添加数据快，索引是用来干什么的，是用来加速查询的，那对你写入数据会有什么影响，肯定是慢一些了，因为你但凡加入一些新的数据，都需要把索引或者说书的目录重新做一个，所以索引虽然会加快查询，但是会降低写入的效率。</p>
<h3 id="2-2-2索引的影响"><a href="#2-2-2索引的影响" class="headerlink" title="2.2.2索引的影响"></a>2.2.2索引的影响</h3><p>1、在表中有大量数据的前提下，创建索引速度会很慢</p>
<p> 2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低</p>
<p> <strong>本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</strong></p>
<p> 数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h3 id="2-2-3-磁盘io与预读"><a href="#2-2-3-磁盘io与预读" class="headerlink" title="2.2..3 磁盘io与预读"></a>2.2..3 磁盘io与预读</h3><p> 前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了，还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。下图是计算机硬件延迟的对比图，供大家参考：</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153237166-685160297.png" alt="img"></p>
<p> 考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<h2 id="2-3-索引的原理"><a href="#2-3-索引的原理" class="headerlink" title="2.3 索引的原理"></a>2.3 索引的原理</h2><p>前面讲了索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，现在我们来看看索引怎么做到减少IO，加速查询的。任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，等到后面讲算法的时候再将，现在这个阶段，你大概了解一下就行了，别深究~~）。</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153244905-527142719.png" alt="img"></p>
<p>　　如上图，是一颗b+树，最上层是树根，中间的是树枝，最下面是叶子节点，关于b+树的定义可以参见<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树</a>，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应四个扇区，可以看到每个磁盘块包含几个数据项（深蓝色所示，一个磁盘块里面包含多少数据，一个深蓝色的块表示一个数据，其实不是数据，后面有解释）和指针（黄色所示，看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p><strong>b+树的查找过程</strong><br>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。</p>
<p><strong>b+树性质</strong><br>1**.索引字段要尽量的小**：通过上面的分析，我们知道IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153252502-161866485.png" alt="img"></p>
<p> 所以我们需要将树建的越低越好，因为每个磁盘块的大小是一定的，那么意味着我们单个数据库里面的单个数据的大小越大越好还是越小越好，你想啊，你现在叶子节点的磁盘块，两个数据就沾满了，你数据要是更大的话，你这一个磁盘块就只能放一个数据了亲，这样随着你数据量的增大，你的树就越高啊，我们应该想办法让树的层数低下来，效率才高啊，所以我们应该让每个数据的大小尽可能的小，那就意味着，你每个磁盘块存的数据就越多，你树的层级就越少啊，树就越低啊，对不对。并且数据的数量越大，你需要的磁盘块越多，磁盘块越多，你需要的树的层级就越高，所以我们应该尽可能的用更少的磁盘块来装更多的数据项，这样树的高度才能降下来，怎么才能装更多的数据项啊，当然是你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。(当然在生产中,索引的配置是根据具体场景来配置的)</p>
<p> 2.<strong>索引的最左匹配特性</strong>：简单来说就是你的数据来了以后，从数据块的左边开始匹配，在匹配右边的，知道这句话就行啦<del>~</del>，我们继续学下面的内容。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h2 id="2-4-聚集索引和辅助索引"><a href="#2-4-聚集索引和辅助索引" class="headerlink" title="2.4 聚集索引和辅助索引"></a>2.4 聚集索引和辅助索引</h2><p><strong>聚集索引是什么呢，其实就是我们说的那个主键，之前我们说Innodb存储引擎的表，必须有一个主键，还记得为什么吗，我们说过的…不记得了吧，看下面</strong></p>
<p>　　　　<strong>还记得MyISAM存储引擎在创建表的时候会在硬盘上生成哪些文件吗，是不是有三个.frm.MYD.MYI结尾的三个文件，frm结尾的是表结构，MYD结尾的是数据文件，MYI结尾的就是索引文件，也就是说索引也是存在硬盘上的，那InnoDB引擎呢，创建一个表，在硬盘上会生成.frm.idb结尾的两个文件，那索引的呢，难道InnoDB就用不了索引吗？怎么可能？之前咱们有没有建立过索引啊，primary key、unique key是不是都叫做索引啊，但是索引那个文件去哪了呢，索引是不可能在表结构.frm（存什么字段什么类型这些东西）的文件中，那就只剩下.idb结尾的数据文件了，索引就在这里面，InnoDB引擎的表，它的索引和数据都在同一个文件里面，所以我一直强调，使用InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据或者说方式，也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。这种索引，我们就称为聚集索引，也就是在聚集数据组织数据的时候，就用这种索引。InnoDB这么做就是为了加速查询效率，因为你经常会遇到基于主键来查询数据的情况，并且通常我们把id字段作为主键，第一点是因为id占用的数据空间不大，第二点是你经常会用到id来查数据。如果你的表有两个字段，一个id一个name，id为主键，当你查询的时候如果where后面的条件是name=多少多少，那么你就没有用到主键给你带来的加速查询的效果（需要主键之外的辅助索引），如果你用where id=多少多少，就会按照我们刚才上面说的哪种树形结构来给你找寻数据了（当然不仅仅有这种树形结构的数据结构类型），能够快速的帮你定位到数据块。这种聚集索引的特点是它会以id字段作为依据，去建立树形结构，但是叶子节点存的是你表中的一条完整记录，一条完整的数据。记住这一点昂，一会将辅助索引的时候，和这个内容有关系，会讲到一个回表的概念。</strong></p>
<p>　　<strong>在数据库中，B+树的高度一般都在2到4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2到4次的IO意味着查询时间只需要0.02~0.04秒。</strong></p>
<p>　　<strong>数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），</strong></p>
<p>　　<strong>聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。</strong></p>
<p>　　<strong>聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息</strong></p>
<h3 id="2-4-1-聚集索引"><a href="#2-4-1-聚集索引" class="headerlink" title="2.4.1 聚集索引"></a>2.4.1 聚集索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</span><br><span class="line">    </span><br><span class="line">#如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。</span><br><span class="line">    </span><br><span class="line">#如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</span><br><span class="line"></span><br><span class="line">#由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</span><br></pre></td></tr></table></figure>

<p> <strong>聚集索引的好处之一</strong><br><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153422151-197456486.png" alt="img"></p>
<p><strong>它对主键的排序查找和范围查找速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录</strong>　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#参照第六小结测试索引的准备阶段来创建出表s1</span><br><span class="line">mysql&gt; desc s1; #最开始没有主键</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   |     | NULL    |       |</span><br><span class="line">| name   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(6)     | YES  |     | NULL    |       |</span><br><span class="line">| email  | varchar(50) | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from s1 order by id desc limit 10; #Using filesort，需要二次排序</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2633472 |   100.00 | Using filesort |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table s1 add primary key(id); #添加主键</span><br><span class="line">Query OK, 0 rows affected (13.37 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from s1 order by id desc limit 10; #基于主键的聚集索引在创建完毕后就已经完成了排序，无需二次排序</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | PRIMARY | 4       | NULL |   10 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>　　　　</p>
<p> <strong>聚集索引的好处之二：范围查询（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table s1 drop primary key;</span><br><span class="line">Query OK, 2699998 rows affected (24.23 sec)</span><br><span class="line">Records: 2699998  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc s1;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   |     | NULL    |       |</span><br><span class="line">| name   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(6)     | YES  |     | NULL    |       |</span><br><span class="line">| email  | varchar(50) | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from s1 where id &gt; 1 and id &lt; 1000000; #没有聚集索引，预估需要检索的rows数如下，explain就是预估一下你的sql的执行效率</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2690100 |    11.11 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table s1 add primary key(id);</span><br><span class="line">Query OK, 0 rows affected (16.25 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from s1 where id &gt; 1 and id &lt; 1000000; #有聚集索引，预估需要检索的rows数如下</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 1343355 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+------+---------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.09 sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-辅助索引"><a href="#2-4-2-辅助索引" class="headerlink" title="2.4.2 辅助索引"></a>2.4.2 辅助索引</h3><p>就是我们在查询的时候，where后面需要写id之外的其他字段名称来进行查询，比如说是where name=xx，没法用到主键索引的效率，怎么办，就需要我们添加辅助索引了，给name添加一个辅助索引。</p>
<p>　　　　表中除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：辅助索引的叶子节点不包含行记录的全部数据。</p>
<p>　　　　叶子节点存放的是对应的那条数据的主键字段的值，除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark），其实这个书签你可以理解为是一个{‘name字段’，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。如果我们select 后面要的是name，我们直接就可以在辅助索引的叶子节点找到对应的name值，比如：select name from tb1 where name=’xx’；这个xx值你直接就在辅助索引的叶子节点就能找到，这种我们也可以称为覆盖索引。如果你select后面的字段不是name，例如：select age from tb1 where name=’xx’；也就是说，我通过辅助索引的叶子节点不能直接拿到age的值，需要通过辅助索引的叶子节点中保存的主键id的值再去通过聚集索引来找到完整的一条记录，然后从这个记录里面拿出age的值，这种操作有时候也成为回表操作，就是从头再回去查一遍，这种的查询效率也很高，但是比覆盖索引低一些，再说一下昂，再辅助索引的叶子节点就能找到你想找的数据可称为覆盖索引。</p>
<h2 id="2-5-mysql-索引管理"><a href="#2-5-mysql-索引管理" class="headerlink" title="2.5 mysql 索引管理"></a>2.5 mysql 索引管理</h2><h3 id="2-5-1-功能"><a href="#2-5-1-功能" class="headerlink" title="2.5.1 功能"></a>2.5.1 功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#1. 索引的功能就是加速查找</span><br><span class="line">#2. mysql中的primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-mysql-常用索引"><a href="#2-5-2-mysql-常用索引" class="headerlink" title="2.5.2 mysql 常用索引"></a>2.5.2 mysql 常用索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">普通索引INDEX：加速查找</span><br><span class="line"></span><br><span class="line">唯一索引：</span><br><span class="line">    -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）</span><br><span class="line">    -唯一索引UNIQUE:加速查找+约束（不能重复）</span><br><span class="line"></span><br><span class="line">联合索引：</span><br><span class="line">    -PRIMARY KEY(id,name):联合主键索引</span><br><span class="line">    -UNIQUE(id,name):联合唯一索引</span><br><span class="line">    -INDEX(id,name):联合普通索引</span><br></pre></td></tr></table></figure>

<p><strong>索引操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">添加主键索引:</span><br><span class="line">创建的时候添加:  添加索引的时候要注意,给字段里面数据大小比较小的字段添加,给字段里面的数据区分度高的字段添加.</span><br><span class="line">聚集索引的添加方式</span><br><span class="line">创建的是添加</span><br><span class="line">Create table t1(</span><br><span class="line">Id int primary key,</span><br><span class="line">)</span><br><span class="line">Create table t1(</span><br><span class="line">Id int,</span><br><span class="line">Primary key(id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">表创建完了之后添加</span><br><span class="line">Alter table 表名 add primary key(id)</span><br><span class="line">删除主键索引:</span><br><span class="line">Alter table 表名 drop primary key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">唯一索引:</span><br><span class="line">Create table t1(</span><br><span class="line">Id int unique,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Create table t1(</span><br><span class="line">Id int,</span><br><span class="line">Unique key uni_name (id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">表创建好之后添加唯一索引:</span><br><span class="line">alter table s1 add unique key  u_name(id);</span><br><span class="line">删除:</span><br><span class="line">Alter table s1 drop index u_name;</span><br><span class="line"></span><br><span class="line">普通索引:</span><br><span class="line">创建:</span><br><span class="line">Create table t1(</span><br><span class="line">Id int,</span><br><span class="line">Index index_name(id)</span><br><span class="line">)</span><br><span class="line">Alter table s1 add index index_name(id);</span><br><span class="line">Create index index_name on s1(id);</span><br><span class="line"></span><br><span class="line">删除:</span><br><span class="line">Alter table s1 drop index u_name;</span><br><span class="line">DROP INDEX 索引名 ON 表名字;</span><br></pre></td></tr></table></figure>

<p><strong>各种索引的应用场景：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">举个例子来说，比如你在为某商场做一个会员卡的系统。</span><br><span class="line"></span><br><span class="line">这个系统有一个会员表</span><br><span class="line">有下列字段：</span><br><span class="line">会员编号 INT</span><br><span class="line">会员姓名 VARCHAR(10)</span><br><span class="line">会员身份证号码 VARCHAR(18)</span><br><span class="line">会员电话 VARCHAR(10)</span><br><span class="line">会员住址 VARCHAR(50)</span><br><span class="line">会员备注信息 TEXT</span><br><span class="line"></span><br><span class="line">那么这个 会员编号，作为主键，使用 PRIMARY</span><br><span class="line">会员姓名 如果要建索引的话，那么就是普通的 INDEX</span><br><span class="line">会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）</span><br><span class="line"></span><br><span class="line">#除此之外还有全文索引，即FULLTEXT</span><br><span class="line">会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。</span><br><span class="line">用于搜索很长一篇文章的时候，效果最好。</span><br><span class="line">用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。</span><br><span class="line">但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。</span><br><span class="line"></span><br><span class="line">#其他的如空间索引SPATIAL，了解即可，几乎不用</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-索引的两大类型hash和btree"><a href="#2-5-3-索引的两大类型hash和btree" class="headerlink" title="2.5.3 索引的两大类型hash和btree"></a>2.5.3 索引的两大类型hash和btree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#我们可以在创建上述索引的时候，为其指定索引类型，分两类</span><br><span class="line">hash类型的索引：查询单条快，范围查询慢</span><br><span class="line">btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）</span><br><span class="line"></span><br><span class="line">#不同的存储引擎支持的索引类型也不一样</span><br><span class="line">InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；</span><br><span class="line">MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；</span><br><span class="line">Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；</span><br><span class="line">NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；</span><br><span class="line">Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；</span><br></pre></td></tr></table></figure>

<h3 id="2-5-4-创建-删除索引的语法"><a href="#2-5-4-创建-删除索引的语法" class="headerlink" title="2.5.4 创建/删除索引的语法"></a>2.5.4 创建/删除索引的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#方法一：创建表时</span><br><span class="line">    　　CREATE TABLE 表名 (</span><br><span class="line">                字段名1  数据类型 [完整性约束条件…],</span><br><span class="line">                字段名2  数据类型 [完整性约束条件…],</span><br><span class="line">                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY</span><br><span class="line">                [索引名]  (字段名[(长度)]  [ASC |DESC]) </span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方法二：CREATE在已存在的表上创建索引</span><br><span class="line">        CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 </span><br><span class="line">                     ON 表名 (字段名[(长度)]  [ASC |DESC]) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方法三：ALTER TABLE在已存在的表上创建索引</span><br><span class="line">        ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX</span><br><span class="line">                             索引名 (字段名[(长度)]  [ASC |DESC]) ;</span><br><span class="line">                             </span><br><span class="line">#删除索引：DROP INDEX 索引名 ON 表名字;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#方式一</span><br><span class="line">create table t1(</span><br><span class="line">    id int,</span><br><span class="line">    name char,</span><br><span class="line">    age int,</span><br><span class="line">    sex enum(&#39;male&#39;,&#39;female&#39;),</span><br><span class="line">    unique key uni_id(id),</span><br><span class="line">    index ix_name(name) #index没有key</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line">create index ix_age on t1(age);</span><br><span class="line"></span><br><span class="line">#方式三</span><br><span class="line">alter table t1 add index ix_sex(sex);</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">mysql&gt; show create table t1;</span><br><span class="line">| t1    | CREATE TABLE &#96;t1&#96; (</span><br><span class="line">  &#96;id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; char(1) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;sex&#96; enum(&#39;male&#39;,&#39;female&#39;) DEFAULT NULL,</span><br><span class="line">  UNIQUE KEY &#96;uni_id&#96; (&#96;id&#96;),</span><br><span class="line">  KEY &#96;ix_name&#96; (&#96;name&#96;),</span><br><span class="line">  KEY &#96;ix_age&#96; (&#96;age&#96;),</span><br><span class="line">  KEY &#96;ix_sex&#96; (&#96;sex&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1</span><br></pre></td></tr></table></figure>

<h2 id="2-6-测试索引"><a href="#2-6-测试索引" class="headerlink" title="2.6 测试索引"></a>2.6 测试索引</h2><h3 id="2-6-1-准备"><a href="#2-6-1-准备" class="headerlink" title="2.6.1 准备"></a>2.6.1 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#1. 准备表</span><br><span class="line">create table s1(</span><br><span class="line">id int,</span><br><span class="line">name varchar(20),</span><br><span class="line">gender char(6),</span><br><span class="line">email varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#2. 创建存储过程，实现批量插入记录</span><br><span class="line">delimiter $$ #声明存储过程的结束符号为$$</span><br><span class="line">create procedure auto_insert1()</span><br><span class="line">BEGIN</span><br><span class="line">    declare i int default 1;</span><br><span class="line">    while(i&lt;3000000)do</span><br><span class="line">        insert into s1 values(i,&#39;egon&#39;,&#39;male&#39;,concat(&#39;egon&#39;,i,&#39;@oldboy&#39;));</span><br><span class="line">        set i&#x3D;i+1;</span><br><span class="line">    end while;</span><br><span class="line">END$$ #$$结束</span><br><span class="line">delimiter ; #重新声明分号为结束符号</span><br><span class="line"></span><br><span class="line">#3. 查看存储过程</span><br><span class="line">show create procedure auto_insert1\G </span><br><span class="line"></span><br><span class="line">#4. 调用存储过程</span><br><span class="line">call auto_insert1();</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-在没有索引的前提下测试查询速度"><a href="#2-6-2-在没有索引的前提下测试查询速度" class="headerlink" title="2.6.2 在没有索引的前提下测试查询速度"></a>2.6.2 在没有索引的前提下测试查询速度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#无索引：mysql根本就不知道到底是否存在id等于333333333的记录，也不知道存在几条id&#x3D;333333333的记录，只能把数据表从头到尾扫描一遍，此时有多少个磁盘块就需要进行多少IO操作，所以查询速度很慢</span><br><span class="line">mysql&gt; select * from s1 where id&#x3D;333333333;</span><br><span class="line">Empty set (0.33 sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-在表中已经存在大量数据的前提下-为某个字段建立索引-建立速度会很慢"><a href="#2-6-3-在表中已经存在大量数据的前提下-为某个字段建立索引-建立速度会很慢" class="headerlink" title="2.6.3 在表中已经存在大量数据的前提下,为某个字段建立索引,建立速度会很慢"></a>2.6.3 在表中已经存在大量数据的前提下,为某个字段建立索引,建立速度会很慢</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index a on s1(id)</span><br><span class="line">Query OK, 0 rows affected (5.30 sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-6-4-建立索引后-以该字段未查询条件时-查询速度明显提升"><a href="#2-6-4-建立索引后-以该字段未查询条件时-查询速度明显提升" class="headerlink" title="2.6.4 建立索引后,以该字段未查询条件时,查询速度明显提升"></a>2.6.4 建立索引后,以该字段未查询条件时,查询速度明显提升</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from s1 where id&#x3D;333333333;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p> <strong>1. mysql先去索引表里根据b+树的搜索原理很快搜索到id等于333333333的记录不存在，IO大大降低，因而速度明显提升</strong></p>
<p> <strong>2. 我们可以去mysql的data目录下找到该表，可以看到占用的硬盘空间多了</strong></p>
<p> <strong>3. 需要注意，如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from s1 where email&#x3D;&#39;xxx&#39;;</span><br><span class="line">Empty set (0.34 sec)   #没有为email加索引,所以以该字段未查询条件,速度依然很慢</span><br></pre></td></tr></table></figure>

<h3 id="2-6-5-总结"><a href="#2-6-5-总结" class="headerlink" title="2.6.5 总结"></a>2.6.5 总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id &#x3D; 333;就需要为id加上索引</span><br><span class="line"></span><br><span class="line">#2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快</span><br><span class="line">比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。</span><br><span class="line">建完以后，再查询就会很快了。</span><br><span class="line"></span><br><span class="line">#3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI</span><br><span class="line"></span><br><span class="line">MySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。</span><br><span class="line">因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.</span><br></pre></td></tr></table></figure>

<h2 id="2-7-正确使用索引"><a href="#2-7-正确使用索引" class="headerlink" title="2.7 正确使用索引"></a>2.7 正确使用索引</h2><h3 id="2-7-1-索引没有命中"><a href="#2-7-1-索引没有命中" class="headerlink" title="2.7.1 索引没有命中"></a>2.7.1 索引没有命中</h3><p> <strong>并不是说我们创建了索引就一定会加快查询速度，\</strong>**若想利用索引达到预想的提高查询速度的效果，我们在添加索引时，必须遵循以下问题**</p>
<h4 id="1-范围问题，或者说条件不明确，条件中出现这些符号或关键字：-gt-、-gt-、-lt-、-lt-、-、between…and…、like、大于号、小于号"><a href="#1-范围问题，或者说条件不明确，条件中出现这些符号或关键字：-gt-、-gt-、-lt-、-lt-、-、between…and…、like、大于号、小于号" class="headerlink" title="1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：**&gt;、&gt;=、&lt;、&lt;=、!= 、between…and…、like、大于号、小于号"></a>1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：*<em>*</em>&gt;、&gt;=、&lt;、&lt;=、!= 、between…and…、like、大于号、小于号</h4><p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153544678-142449703.png" alt="img"></p>
<p>　　　　如果你写where id &gt;1 and id &lt;1000000;你会发现，随着你范围的增大，速度会越来越慢，会成倍的体现出来。</p>
<p>　　　　不等于！=</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153549494-1076685599.png" alt="img"></p>
<p>　　　　between …and…</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153554167-1437094022.png" alt="img"></p>
<p> like #测like的时候，你可以先把id的主键索引去掉，然后测一下like，然后加上index key，再测一下。就知道你忘了，看语句：create index email_index on s1(email) ，email_index是索引名、on、 s1是表名（字段名），你会发现建索引的时间也是很慢的，desc s1;查看一下索引是不是创建成功了，看那个key字段是不是有个mul，有这个说明创建成功了。</p>
<p> like=后面如果没有那些特殊字符，通配符之类的，就跟等于是一个效果，精确匹配。</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153600593-1903115087.png" alt="img"></p>
<p>　　　　<strong>使用like的时候，通配符写在最前面，也是需要全匹配一遍，然后在比较字符串的第二个字符，最左匹配的规则，还记得吗。</strong></p>
<h4 id="2-尽量选择区分度高的列作为索引-区分度的公式是count-distinct-col-count-，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0-1以上，即平均1条扫描10条记录"><a href="#2-尽量选择区分度高的列作为索引-区分度的公式是count-distinct-col-count-，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0-1以上，即平均1条扫描10条记录" class="headerlink" title="2 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录"></a>2 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#先把表中的索引都删除，让我们专心研究区分度的问题</span><br><span class="line">mysql&gt; desc s1;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | YES  | MUL | NULL    |       |</span><br><span class="line">| name   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(5)     | YES  |     | NULL    |       |</span><br><span class="line">| email  | varchar(50) | YES  | MUL | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; drop index a on s1;</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; drop index d on s1;</span><br><span class="line">Query OK, 0 rows affected (0.18 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc s1;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| name   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(5)     | YES  |     | NULL    |       |</span><br><span class="line">| email  | varchar(50) | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153609568-1535087839.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们编写存储过程为表s1批量添加记录，name字段的值均为egon，也就是说name这个字段的区分度很低（gender字段也是一样的，我们稍后再搭理它）</span><br><span class="line"></span><br><span class="line">回忆b+树的结构，查询的速度与树的高度成反比，要想将树的高低控制的很低，需要保证：在某一层内数据项均是按照从左到右，从小到大的顺序依次排开，即左1&lt;左2&lt;左3&lt;...</span><br><span class="line"></span><br><span class="line">而对于区分度低的字段，无法找到大小关系，因为值都是相等的，毫无疑问，还想要用b+树存放这些等值的数据，只能增加树的高度，字段的区分度越低，则树的高度越高。极端的情况，索引字段的值都一样，那么b+树几乎成了一根棍。本例中就是这种极端的情况，name字段所有的值均为&#39;egon&#39;</span><br><span class="line"></span><br><span class="line">#现在我们得出一个结论：为区分度低的字段建立索引，索引树的高度会很高，然而这具体会带来什么影响呢？？？</span><br><span class="line"></span><br><span class="line">#1：如果条件是name&#x3D;&#39;xxxx&#39;,那么肯定是可以第一时间判断出&#39;xxxx&#39;是不在索引树中的（因为树中所有的值均为&#39;egon’,看第一条的时候就知道你不在索引树里面了），所以查询速度很快</span><br><span class="line"></span><br><span class="line">#2：如果条件正好是name&#x3D;&#39;egon&#39;,查询时，我们永远无法从树的某个位置得到一个明确的范围，只能往下找，往下找，往下找。。。这与全表扫描的IO次数没有多大区别，所以速度很慢</span><br></pre></td></tr></table></figure>

<h4 id="3-和in可以乱序，比如a-1-and-b-2-and-c-3-建立-a-b-c-索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式"><a href="#3-和in可以乱序，比如a-1-and-b-2-and-c-3-建立-a-b-c-索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式" class="headerlink" title="3 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式"></a>3 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</h4><h4 id="4-索引列不能参与计算，保持列“干净”，比如from-unixtime-create-time-’2014-05-29’就不能使用到索引，原因很简单，b-树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create-time-unix-timestamp-’2014-05-29’"><a href="#4-索引列不能参与计算，保持列“干净”，比如from-unixtime-create-time-’2014-05-29’就不能使用到索引，原因很简单，b-树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create-time-unix-timestamp-’2014-05-29’" class="headerlink" title="4 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)"></a>4 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)</h4><p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153619312-2087128773.png" alt="img"></p>
<p> <strong>把上面的条件写成 where id = 3000/3;你会发现速度变得很快，因为等于号后面的数字，是在比较之前就计算出来了，不需要每次都计算一次每次都计算一次了，跟直接等于一个常数是一样的，所以很快。结论是不要让你的索引字段参与到计算中。</strong></p>
<h4 id="5-and-or"><a href="#5-and-or" class="headerlink" title="5 and/or"></a>5 and/or</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#1、and与or的逻辑</span><br><span class="line">    条件1 and 条件2:所有条件都成立才算成立，但凡要有一个条件不成立则最终结果不成立</span><br><span class="line">    条件1 or 条件2:只要有一个条件成立则最终结果就成立</span><br><span class="line"></span><br><span class="line">#2、and的工作原理</span><br><span class="line">    条件：</span><br><span class="line">        a &#x3D; 10 and b &#x3D; &#39;xxx&#39; and c &gt; 3 and d &#x3D;4</span><br><span class="line">    索引：</span><br><span class="line">        制作联合索引(d,a,b,c)</span><br><span class="line">    工作原理:  #如果是你找的话，你会怎么找，是不是从左到右一个一个的比较啊，首先你不能确定a这个字段是不是有索引，即便是有索引，也不一定能确保命中索引了（所谓命中索引，就是应用上了索引），mysql不会这么笨的，看下面mysql是怎么找的：</span><br><span class="line">        索引的本质原理就是先不断的把查找范围缩小下来，然后再进行处理，对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，即按照d—&gt;a-&gt;b-&gt;c的顺序</span><br><span class="line"></span><br><span class="line">#3、or的工作原理</span><br><span class="line">    条件：</span><br><span class="line">        a &#x3D; 10 or b &#x3D; &#39;xxx&#39; or c &gt; 3 or d &#x3D;4</span><br><span class="line">    索引：</span><br><span class="line">        制作联合索引(d,a,b,c)</span><br><span class="line">        </span><br><span class="line">    工作原理:</span><br><span class="line">        只要一个匹配成功就行，所以对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a-&gt;b-&gt;c-&gt;d</span><br></pre></td></tr></table></figure>

<p>索引要加在数据区分度高的字段上</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153630415-1707823376.png" alt="img"></p>
<p> 在左边条件成立但是索引字段的区分度低的情况下（name与gender均属于这种情况），会依次往右找到一个区分度高的索引字段，加速查询</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153635337-1400046793.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153639262-1394935042.png" alt="img"></p>
<p> 经过分析，在条件为name=’egon’ and gender=’male’ and id&gt;333 and email=’xxx’的情况下，我们完全没必要为前三个条件的字段加索引，因为只能用上email字段的索引，前三个字段的索引反而会降低我们的查询效率</p>
<p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153643362-658190876.png" alt="img"></p>
<h4 id="6-最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询-gt-、-lt-、between、like-就停止匹配-指的是范围大了，有索引速度也慢-，比如a-1-and-b-2-and-c-gt-3-and-d-4-如果建立-a-b-c-d-顺序的索引，d是用不到索引的，如果建立-a-b-d-c-的索引则都可以用到，a-b-d的顺序可以任意调整。"><a href="#6-最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询-gt-、-lt-、between、like-就停止匹配-指的是范围大了，有索引速度也慢-，比如a-1-and-b-2-and-c-gt-3-and-d-4-如果建立-a-b-c-d-顺序的索引，d是用不到索引的，如果建立-a-b-d-c-的索引则都可以用到，a-b-d的顺序可以任意调整。" class="headerlink" title="6 最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。"></a>6 最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</h4><p><img src="https://img2018.cnblogs.com/blog/1730003/201909/1730003-20190904153821683-965016448.png" alt="img"></p>
<h4 id="7-其他情况"><a href="#7-其他情况" class="headerlink" title="7 其他情况"></a>7 其他情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- 使用函数</span><br><span class="line">    select * from tb1 where reverse(email) &#x3D; &#39;egon&#39;;</span><br><span class="line">            </span><br><span class="line">- 类型不一致</span><br><span class="line">    如果列是字符串类型，传入条件是必须用引号引起来，不然...</span><br><span class="line">    select * from tb1 where email &#x3D; 999;</span><br><span class="line">    </span><br><span class="line">#排序条件为索引，则select字段必须也是索引字段，否则无法命中</span><br><span class="line">- order by</span><br><span class="line">    select name from s1 order by email desc;</span><br><span class="line">    当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢</span><br><span class="line">    select email from s1 order by email desc;</span><br><span class="line">    特别的：如果对主键排序，则还是速度很快：</span><br><span class="line">        select * from tb1 order by nid desc;</span><br><span class="line"> </span><br><span class="line">- 组合索引最左前缀</span><br><span class="line">    如果组合索引为：(name,email)</span><br><span class="line">    name and email       -- 命中索引</span><br><span class="line">    name                 -- 命中索引</span><br><span class="line">    email                -- 未命中索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- count(1)或count(列)代替count(*)在mysql中没有差别了</span><br><span class="line"></span><br><span class="line">- create index xxxx  on tb(title(19)) #text类型，必须制定长度</span><br></pre></td></tr></table></figure>

<p><strong>其他注意事项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 避免使用select *</span><br><span class="line">- count(1)或count(列) 代替 count(*) **存疑**</span><br><span class="line">		InnoDB引擎下：</span><br><span class="line">		1.count(*)和count(1)的效率是一样的！两者没有性能差异！</span><br><span class="line">			如果表存在主键，他们都是根据主键去count的，速度都较快；如果不存在主键，则速度都较慢！</span><br><span class="line">		2.count(1) &#x2F;count(*)会统计表中的所有的记录数，包含字段为null 的记录；</span><br><span class="line">			count(列名) 会统计该字段在表中出现的次数，不统计字段为null 的记录。</span><br><span class="line">			且在效率方面count(非主键列)的效率往往低于count(*)&#x2F;count(1) ！count(主键列)效率差不多！</span><br><span class="line">- 创建表时尽量时 char 代替 varchar</span><br><span class="line">- 表的字段顺序固定长度的字段优先</span><br><span class="line">- 组合索引代替多个单列索引（经常使用多个条件查询时）</span><br><span class="line">- 尽量使用短索引</span><br><span class="line">- 使用连接（JOIN）来代替子查询(Sub-Queries)</span><br><span class="line">- 连表时注意条件类型需一致</span><br><span class="line">- 索引散列值（重复少）不适合建索引，例：性别不适合</span><br></pre></td></tr></table></figure>

<h2 id="2-8-联合索引和覆盖索引"><a href="#2-8-联合索引和覆盖索引" class="headerlink" title="2.8 联合索引和覆盖索引"></a>2.8 联合索引和覆盖索引</h2><h3 id="2-8-1-联合索引"><a href="#2-8-1-联合索引" class="headerlink" title="2.8.1 联合索引"></a>2.8.1 联合索引</h3><p>　　　　联合索引时指对表上的多个列合起来做一个索引，省的你查询的时候，where后面的条件字段一直再变，你就想给每个字段加索引的尴尬问题。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t(</span><br><span class="line">    -&gt; a int,</span><br><span class="line">    -&gt; b int,</span><br><span class="line">    -&gt; primary key(a),</span><br><span class="line">    -&gt; key idx_a_b(a,b)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure>

<p>　　　　<strong>注意建立联合索引的一个原则：</strong>索引是有个最左匹配的原则的，所以建联合索引的时候，将区分度高的放在最左边，依次排下来，范围查询的条件尽可能的往后边放。</p>
<p>　　　　<strong>联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理</strong>，例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;准备表&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">create table buy_log(</span><br><span class="line">    userid int unsigned not null,</span><br><span class="line">    buy_date date</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into buy_log values</span><br><span class="line">(1,&#39;2009-01-01&#39;),</span><br><span class="line">(2,&#39;2009-01-01&#39;),</span><br><span class="line">(3,&#39;2009-01-01&#39;),</span><br><span class="line">(1,&#39;2009-02-01&#39;),</span><br><span class="line">(3,&#39;2009-02-01&#39;),</span><br><span class="line">(1,&#39;2009-03-01&#39;),</span><br><span class="line">(1,&#39;2009-04-01&#39;);</span><br><span class="line"></span><br><span class="line">alter table buy_log add key(userid);</span><br><span class="line">alter table buy_log add key(userid,buy_date);</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;验证&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">mysql&gt; show create table buy_log;</span><br><span class="line">| buy_log | CREATE TABLE &#96;buy_log&#96; (</span><br><span class="line">  &#96;userid&#96; int(10) unsigned NOT NULL,</span><br><span class="line">  &#96;buy_date&#96; date DEFAULT NULL,</span><br><span class="line">  KEY &#96;userid&#96; (&#96;userid&#96;),</span><br><span class="line">  KEY &#96;userid_2&#96; (&#96;userid&#96;,&#96;buy_date&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 |</span><br><span class="line"></span><br><span class="line">#可以看到possible_keys在这里有两个索引可以用，分别是单个索引userid与联合索引userid_2,但是优化器最终选择了使用的key是userid因为该索引的叶子节点包含单个键值，所以理论上一个页能存放的记录应该更多</span><br><span class="line">mysql&gt; explain select * from buy_log where userid&#x3D;2;</span><br><span class="line">+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table   | type | possible_keys   | key    | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | buy_log | ref  | userid,userid_2 | userid | 4       | const |    1 |       |</span><br><span class="line">+----+-------------+---------+------+-----------------+--------+---------+-------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#接着假定要取出userid为1的最近3次的购买记录，用的就是联合索引userid_2了，因为在这个索引中，在userid&#x3D;1的情况下，buy_date都已经排序好了</span><br><span class="line">mysql&gt; explain select * from buy_log where userid&#x3D;1 order by buy_date desc limit 3;</span><br><span class="line">+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">| id | select_type | table   | type | possible_keys   | key      | key_len | ref   | rows | Extra                    |</span><br><span class="line">+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | buy_log | ref  | userid,userid_2 | userid_2 | 4       | const |    4 | Using where; Using index |</span><br><span class="line">+----+-------------+---------+------+-----------------+----------+---------+-------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">#ps：如果extra的排序显示是Using filesort，则意味着在查出数据后需要二次排序(如下查询语句，没有先用where userid&#x3D;3先定位范围，于是即便命中索引也没用，需要二次排序)</span><br><span class="line">mysql&gt; explain select * from buy_log order by buy_date desc limit 3;</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+</span><br><span class="line">| id | select_type | table   | type  | possible_keys | key      | key_len | ref  | rows | Extra                       |</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | buy_log | index | NULL          | userid_2 | 8       | NULL |    7 | Using index; Using filesort |</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+-----------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对于联合索引（a,b）,下述语句可以直接使用该索引，无需二次排序</span><br><span class="line">select ... from table where a&#x3D;xxx order by b;</span><br><span class="line"></span><br><span class="line">#然后对于联合索引(a,b,c)来首，下列语句同样可以直接通过索引得到结果</span><br><span class="line">select ... from table where a&#x3D;xxx order by b;</span><br><span class="line">select ... from table where a&#x3D;xxx and b&#x3D;xxx order by c;</span><br><span class="line"></span><br><span class="line">#但是对于联合索引(a,b,c)，下列语句不能通过索引直接得到结果，还需要自己执行一次filesort操作，因为索引（a，c)并未排序</span><br><span class="line">select ... from table where a&#x3D;xxx order by c; </span><br></pre></td></tr></table></figure>

<h3 id="2-8-2-覆盖索引"><a href="#2-8-2-覆盖索引" class="headerlink" title="2.8.2 覆盖索引"></a>2.8.2 覆盖索引</h3><p> <strong>InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。</strong></p>
<p> <strong>使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作</strong></p>
<p> <strong>注意：覆盖索引技术最早是在InnoDB Plugin中完成并实现，这意味着对于InnoDB版本小于1.0的，或者MySQL数据库版本为5.0以下的，InnoDB存储引擎不支持覆盖索引特性</strong></p>
<p> <strong>对于InnoDB存储引擎的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为（primary key1，priamey key2，…,key1，key2，…）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">select age from s1 where id&#x3D;123 and name &#x3D; &#39;egon&#39;; #id字段有索引，但是name字段没有索引,该sql命中了索引，但未覆盖，需要去聚集索引中再查找详细信息。</span><br><span class="line">最牛逼的情况是，索引字段覆盖了所有，那全程通过索引来加速查询以及获取结果就ok了</span><br><span class="line">mysql&gt; desc s1;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id | int(11) | NO | | NULL | |</span><br><span class="line">| name | varchar(20) | YES | | NULL | |</span><br><span class="line">| gender | char(6) | YES | | NULL | |</span><br><span class="line">| email | varchar(50) | YES | | NULL | |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.21 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select name from s1 where id&#x3D;1000; #没有任何索引</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">| 1 | SIMPLE | s1 | NULL | ALL | NULL | NULL | NULL | NULL | 2688336 | 10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create index idx_id on s1(id); #创建索引</span><br><span class="line">Query OK, 0 rows affected (4.16 sec)</span><br><span class="line">Records: 0 Duplicates: 0 Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select name from s1 where id&#x3D;1000; #命中辅助索引，但是未覆盖索引，还需要从聚集索引中查找name</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+</span><br><span class="line">| 1 | SIMPLE | s1 | NULL | ref | idx_id | idx_id | 4 | const | 1 | 100.00 | NULL |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select id from s1 where id&#x3D;1000; #在辅助索引中就找到了全部信息，Using index代表覆盖索引</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+</span><br><span class="line">| 1 | SIMPLE | s1 | NULL | ref | idx_id | idx_id | 4 | const | 1 | 100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+--------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p><strong>覆盖索引的另一个好处是对某些统计问题而言,基于上一小节创建的表buy_log,查询计划如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select count(*) from buy_log;</span><br><span class="line">+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table   | type  | possible_keys | key    | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | buy_log | index | NULL          | userid | 4       | NULL |    7 | Using index |</span><br><span class="line">+----+-------------+---------+-------+---------------+--------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>　　　　innodb存储引擎并不会选择通过查询聚集索引来进行统计。由于buy_log表有辅助索引，而辅助索引远小于聚集索引，选择辅助索引可以减少IO操作，故优化器的选择如上key为userid辅助索引</p>
<p>　　　　<strong>对于（a,b）形式的联合索引，一般是不可以选择b中所谓的查询条件。但如果是统计操作，并且是覆盖索引，则优化器还是会选择使用该索引，如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#联合索引userid_2（userid,buy_date）,一般情况，我们按照buy_date是无法使用该索引的，但特殊情况下：查询语句是统计操作，且是覆盖索引，则按照buy_date当做查询条件时，也可以使用该联合索引</span><br><span class="line">mysql&gt; explain select count(*) from buy_log where buy_date &gt;&#x3D; &#39;2011-01-01&#39; and buy_date &lt; &#39;2011-02-01&#39;;</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+</span><br><span class="line">| id | select_type | table   | type  | possible_keys | key      | key_len | ref  | rows | Extra                    |</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | buy_log | index | NULL          | userid_2 | 8       | NULL |    7 | Using where; Using index |</span><br><span class="line">+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="2-9-查询优化神奇-explain"><a href="#2-9-查询优化神奇-explain" class="headerlink" title="2.9 查询优化神奇-explain"></a>2.9 查询优化神奇-explain</h2><p>　　<strong>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行计划：让mysql预估执行操作(一般正确)</span><br><span class="line">		type的值</span><br><span class="line">    all &lt; index &lt; range &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; const&#x2F;system &lt; null</span><br><span class="line">    慢：</span><br><span class="line">        select * from userinfo3 where name&#x3D;&#39;alex&#39;</span><br><span class="line">        </span><br><span class="line">        explain select * from userinfo3 where name&#x3D;&#39;alex&#39;</span><br><span class="line">        type: ALL(全表扫描)</span><br><span class="line">            select * from userinfo3 limit 1;</span><br><span class="line">    快：</span><br><span class="line">        select * from userinfo3 where email&#x3D;&#39;alex&#39;</span><br><span class="line">        type: const(走索引)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain select .....</span><br><span class="line">结果:</span><br><span class="line">id:选择标识符</span><br><span class="line">select_type:表示查询的类型。</span><br><span class="line">table:输出结果集的表</span><br><span class="line">partitions:匹配的分区</span><br><span class="line">type:表示表的连接类型</span><br><span class="line">possible_keys:表示查询时，可能使用的索引</span><br><span class="line">key:表示实际使用的索引</span><br><span class="line">key_len:索引字段的长度</span><br><span class="line">ref:列与索引的比较</span><br><span class="line">rows:扫描出的行数(估算的行数)</span><br><span class="line">filtered:按表条件过滤的行百分比</span><br><span class="line">Extra:执行情况的描述和说明</span><br></pre></td></tr></table></figure>

<h3 id="1-id"><a href="#1-id" class="headerlink" title="1 id"></a>1 id</h3><p>SELECT识别符。这是SELECT的查询序列号</p>
<p><strong>我的理解是SQL执行的顺序的标识，SQL从大到小的执行</strong></p>
<p>\1. id相同时，执行顺序由上至下</p>
<p>\2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<p>\3. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p>
<h3 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2 select_type"></a>2 select_type</h3><p>   <strong><em>\</em>示查询中每个select子句的类型**</strong></p>
<p>(1) SIMPLE(简单SELECT，不使用UNION或子查询等)</p>
<p>(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p>
<p>(3) UNION(UNION中的第二个或后面的SELECT语句)</p>
<p>(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p>
<p>(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p>
<p>(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p>
<p>(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p>
<p>(8) DERIVED(派生表的SELECT, FROM子句的子查询)</p>
<p>(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p>
<h3 id="3-table"><a href="#3-table" class="headerlink" title="3 table"></a>3 table</h3><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p>
<h3 id="4-type"><a href="#4-type" class="headerlink" title="4 type"></a>4 <strong>type</strong></h3><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。</p>
<p>常用的类型有： <strong>ALL、index、range、 ref、eq_ref、const、system、**</strong>NULL（从左到右，性能从差到好）**</p>
<p>ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行</p>
<p>index: Full Index Scan，index与ALL区别为index类型只遍历索引树</p>
<p>range:只检索给定范围的行，使用一个索引来选择行</p>
<p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p>
<p>const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system</p>
<p>NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<h3 id="5-possible-keys"><a href="#5-possible-keys" class="headerlink" title="5 possible_keys"></a>5 <strong>possible_keys</strong></h3><p><strong>指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</strong></p>
<p>该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询</p>
<h3 id="6-Key"><a href="#6-Key" class="headerlink" title="6 Key"></a>6 <strong>Key</strong></h3><p><strong>key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中</strong></p>
<p>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<h3 id="7-key-len"><a href="#7-key-len" class="headerlink" title="7 key_len"></a>7 <strong>key_len</strong></h3><p><strong>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）</strong></p>
<p>不损失精确性的情况下，长度越短越好 </p>
<h3 id="8-ref"><a href="#8-ref" class="headerlink" title="8 ref"></a>8 <strong>ref</strong></h3><p><strong>列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</strong></p>
<h3 id="9-rows"><a href="#9-rows" class="headerlink" title="9 rows"></a>9 <strong>rows</strong></h3><p> <strong>估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</strong></p>
<h3 id="10-extra"><a href="#10-extra" class="headerlink" title="10 extra"></a>10 extra</h3><p><strong>该列包含MySQL解决查询的详细信息,有以下几种情况：</strong></p>
<p>Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</p>
<p>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p>
<p>Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 测试Extra的filesort</span><br><span class="line">explain select * from emp order by name;</span><br></pre></td></tr></table></figure>

<p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p>Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。</p>
<p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<p>No tables used：Query语句中使用from dual 或不含任何from子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- explain select now() from dual;</span><br></pre></td></tr></table></figure>

<h3 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a>10 总结</h3><p><strong>• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况<br>• EXPLAIN不考虑各种Cache<br>• EXPLAIN不能显示MySQL在执行查询时所作的优化工作<br>• 部分统计信息是估算的，并非精确值<br>• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。</strong></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>HF
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2017/07/02/Mysql%E4%BC%98%E5%8C%96/" title="Mysql优化">http://example.com/2017/07/02/Mysql优化/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/03/01/%E6%97%85%E6%B8%B8/" rel="prev" title="Base">
      <i class="fa fa-chevron-left"></i> Base
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/07/03/linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/" rel="next" title="linux根目录权限修复方法">
      linux根目录权限修复方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-mysql%E7%9A%84%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">一 mysql的大表优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">2 单表优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-mysql%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">2.</span> <span class="nav-text">二 mysql的索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 索引介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 索引的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 索引原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2索引的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E7%A3%81%E7%9B%98io%E4%B8%8E%E9%A2%84%E8%AF%BB"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2..3 磁盘io与预读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 索引的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 聚集索引和辅助索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 聚集索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 辅助索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-mysql-%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 mysql 索引管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E5%8A%9F%E8%83%BD"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-mysql-%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 mysql 常用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%B1%BB%E5%9E%8Bhash%E5%92%8Cbtree"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 索引的两大类型hash和btree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-%E5%88%9B%E5%BB%BA-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4 创建&#x2F;删除索引的语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E6%B5%8B%E8%AF%95%E7%B4%A2%E5%BC%95"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 测试索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E5%87%86%E5%A4%87"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E5%9C%A8%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E6%B5%8B%E8%AF%95%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 在没有索引的前提下测试查询速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E5%9C%A8%E8%A1%A8%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B-%E4%B8%BA%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95-%E5%BB%BA%E7%AB%8B%E9%80%9F%E5%BA%A6%E4%BC%9A%E5%BE%88%E6%85%A2"><span class="nav-number">2.6.3.</span> <span class="nav-text">2.6.3 在表中已经存在大量数据的前提下,为某个字段建立索引,建立速度会很慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-4-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E5%90%8E-%E4%BB%A5%E8%AF%A5%E5%AD%97%E6%AE%B5%E6%9C%AA%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E6%97%B6-%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%98%8E%E6%98%BE%E6%8F%90%E5%8D%87"><span class="nav-number">2.6.4.</span> <span class="nav-text">2.6.4 建立索引后,以该字段未查询条件时,查询速度明显提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-5-%E6%80%BB%E7%BB%93"><span class="nav-number">2.6.5.</span> <span class="nav-text">2.6.5 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 正确使用索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E7%B4%A2%E5%BC%95%E6%B2%A1%E6%9C%89%E5%91%BD%E4%B8%AD"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.7.1 索引没有命中</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%8C%83%E5%9B%B4%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%98%8E%E7%A1%AE%EF%BC%8C%E6%9D%A1%E4%BB%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%99%E4%BA%9B%E7%AC%A6%E5%8F%B7%E6%88%96%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A-gt-%E3%80%81-gt-%E3%80%81-lt-%E3%80%81-lt-%E3%80%81-%E3%80%81between%E2%80%A6and%E2%80%A6%E3%80%81like%E3%80%81%E5%A4%A7%E4%BA%8E%E5%8F%B7%E3%80%81%E5%B0%8F%E4%BA%8E%E5%8F%B7"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：**&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、!&#x3D; 、between…and…、like、大于号、小于号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B0%BD%E9%87%8F%E9%80%89%E6%8B%A9%E5%8C%BA%E5%88%86%E5%BA%A6%E9%AB%98%E7%9A%84%E5%88%97%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95-%E5%8C%BA%E5%88%86%E5%BA%A6%E7%9A%84%E5%85%AC%E5%BC%8F%E6%98%AFcount-distinct-col-count-%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%AD%97%E6%AE%B5%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%AF%94%E4%BE%8B%EF%BC%8C%E6%AF%94%E4%BE%8B%E8%B6%8A%E5%A4%A7%E6%88%91%E4%BB%AC%E6%89%AB%E6%8F%8F%E7%9A%84%E8%AE%B0%E5%BD%95%E6%95%B0%E8%B6%8A%E5%B0%91%EF%BC%8C%E5%94%AF%E4%B8%80%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%86%E5%BA%A6%E6%98%AF1%EF%BC%8C%E8%80%8C%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E3%80%81%E6%80%A7%E5%88%AB%E5%AD%97%E6%AE%B5%E5%8F%AF%E8%83%BD%E5%9C%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E5%89%8D%E5%8C%BA%E5%88%86%E5%BA%A6%E5%B0%B1%E6%98%AF0%EF%BC%8C%E9%82%A3%E5%8F%AF%E8%83%BD%E6%9C%89%E4%BA%BA%E4%BC%9A%E9%97%AE%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%AF%94%E4%BE%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%8F%E9%AA%8C%E5%80%BC%E5%90%97%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%80%BC%E4%B9%9F%E5%BE%88%E9%9A%BE%E7%A1%AE%E5%AE%9A%EF%BC%8C%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81join%E7%9A%84%E5%AD%97%E6%AE%B5%E6%88%91%E4%BB%AC%E9%83%BD%E8%A6%81%E6%B1%82%E6%98%AF0-1%E4%BB%A5%E4%B8%8A%EF%BC%8C%E5%8D%B3%E5%B9%B3%E5%9D%871%E6%9D%A1%E6%89%AB%E6%8F%8F10%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">2 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%92%8Cin%E5%8F%AF%E4%BB%A5%E4%B9%B1%E5%BA%8F%EF%BC%8C%E6%AF%94%E5%A6%82a-1-and-b-2-and-c-3-%E5%BB%BA%E7%AB%8B-a-b-c-%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E4%BB%BB%E6%84%8F%E9%A1%BA%E5%BA%8F%EF%BC%8Cmysql%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E4%BC%9A%E5%B8%AE%E4%BD%A0%E4%BC%98%E5%8C%96%E6%88%90%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E8%AF%86%E5%88%AB%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">3 &#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8D%E8%83%BD%E5%8F%82%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%8C%E4%BF%9D%E6%8C%81%E5%88%97%E2%80%9C%E5%B9%B2%E5%87%80%E2%80%9D%EF%BC%8C%E6%AF%94%E5%A6%82from-unixtime-create-time-%E2%80%992014-05-29%E2%80%99%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%8E%9F%E5%9B%A0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8Cb-%E6%A0%91%E4%B8%AD%E5%AD%98%E7%9A%84%E9%83%BD%E6%98%AF%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%80%BC%EF%BC%8C%E4%BD%86%E8%BF%9B%E8%A1%8C%E6%A3%80%E7%B4%A2%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%8D%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%8C%E6%98%BE%E7%84%B6%E6%88%90%E6%9C%AC%E5%A4%AA%E5%A4%A7%E3%80%82%E6%89%80%E4%BB%A5%E8%AF%AD%E5%8F%A5%E5%BA%94%E8%AF%A5%E5%86%99%E6%88%90create-time-unix-timestamp-%E2%80%992014-05-29%E2%80%99"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">4 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-and-or"><span class="nav-number">2.7.1.5.</span> <span class="nav-text">5 and&#x2F;or</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%88%E8%AF%A6%E8%A7%81%E7%AC%AC%E5%85%AB%E5%B0%8F%E8%8A%82%EF%BC%89%EF%BC%8C%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%8C%E5%AF%B9%E4%BA%8E%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95mysql%E4%BC%9A%E4%B8%80%E7%9B%B4%E5%90%91%E5%8F%B3%E5%8C%B9%E9%85%8D%E7%9B%B4%E5%88%B0%E9%81%87%E5%88%B0%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2-gt-%E3%80%81-lt-%E3%80%81between%E3%80%81like-%E5%B0%B1%E5%81%9C%E6%AD%A2%E5%8C%B9%E9%85%8D-%E6%8C%87%E7%9A%84%E6%98%AF%E8%8C%83%E5%9B%B4%E5%A4%A7%E4%BA%86%EF%BC%8C%E6%9C%89%E7%B4%A2%E5%BC%95%E9%80%9F%E5%BA%A6%E4%B9%9F%E6%85%A2-%EF%BC%8C%E6%AF%94%E5%A6%82a-1-and-b-2-and-c-gt-3-and-d-4-%E5%A6%82%E6%9E%9C%E5%BB%BA%E7%AB%8B-a-b-c-d-%E9%A1%BA%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%8Cd%E6%98%AF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%B4%A2%E5%BC%95%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%BB%BA%E7%AB%8B-a-b-d-c-%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%99%E9%83%BD%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%88%B0%EF%BC%8Ca-b-d%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%8F%AF%E4%BB%A5%E4%BB%BB%E6%84%8F%E8%B0%83%E6%95%B4%E3%80%82"><span class="nav-number">2.7.1.6.</span> <span class="nav-text">6 最左前缀匹配原则（详见第八小节），非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="nav-number">2.7.1.7.</span> <span class="nav-text">7 其他情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 联合索引和覆盖索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1 联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2 覆盖索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%A5%9E%E5%A5%87-explain"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 查询优化神奇-explain</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-id"><span class="nav-number">2.9.1.</span> <span class="nav-text">1 id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-select-type"><span class="nav-number">2.9.2.</span> <span class="nav-text">2 select_type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-table"><span class="nav-number">2.9.3.</span> <span class="nav-text">3 table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-type"><span class="nav-number">2.9.4.</span> <span class="nav-text">4 type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-possible-keys"><span class="nav-number">2.9.5.</span> <span class="nav-text">5 possible_keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Key"><span class="nav-number">2.9.6.</span> <span class="nav-text">6 Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-key-len"><span class="nav-number">2.9.7.</span> <span class="nav-text">7 key_len</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-ref"><span class="nav-number">2.9.8.</span> <span class="nav-text">8 ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-rows"><span class="nav-number">2.9.9.</span> <span class="nav-text">9 rows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-extra"><span class="nav-number">2.9.10.</span> <span class="nav-text">10 extra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%80%BB%E7%BB%93"><span class="nav-number">2.9.11.</span> <span class="nav-text">10 总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HF"
      src="/images/hexo.jpg">
  <p class="site-author-name" itemprop="name">HF</p>
  <div class="site-description" itemprop="description">第二名就是头号输家</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.54tianzhisheng.cn/tags/Flink/" title="http:&#x2F;&#x2F;www.54tianzhisheng.cn&#x2F;tags&#x2F;Flink&#x2F;" rel="noopener" target="_blank">Flink</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://nginxconfig.io/" title="https:&#x2F;&#x2F;nginxconfig.io&#x2F;" rel="noopener" target="_blank">Nginxconfig</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://linux.51yip.com/" title="http:&#x2F;&#x2F;linux.51yip.com&#x2F;" rel="noopener" target="_blank">Linux命令手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://echarts.baidu.com/index.html" title="https:&#x2F;&#x2F;echarts.baidu.com&#x2F;index.html" rel="noopener" target="_blank">echarts可视化库</a>
        </li>
    </ul>
  </div>
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>

    
          <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
         <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
           <div class="widget-wrap">
        <h3 class="widget-title">Tag Cloud</h3>
        <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width=100%">
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClickHouse/" rel="tag">ClickHouse</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ElSearch/" rel="tag">ElSearch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/" rel="tag">Flink</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flume/" rel="tag">Flume</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/" rel="tag">Hadoop</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hbase/" rel="tag">Hbase</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Impala/" rel="tag">Impala</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Livy/" rel="tag">Livy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oozie/" rel="tag">Oozie</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/" rel="tag">Scala</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/" rel="tag">Spark</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sqoop/" rel="tag">Sqoop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZK/" rel="tag">ZK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%86%E5%8F%B2/" rel="tag">历史</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E4%BB%93/" rel="tag">数仓</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag">数据分析</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">数据可视化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1/" rel="tag">统计</a><span class="tag-list-count">1</span></li></ul>
            </canvas>
        </div>
    </div>
    

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright" style=" text-align:center;">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HF</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:52</span>
</div>

  <!-- 网站运行时间的设置 -->
<div class="run_time" style=" text-align:center;">
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
  <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("07/23/2017 10:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
    setInterval("createtime()",250);
  </script>
</div>
        
<div class="busuanzi-count" style=" text-align:center;">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友，
    </span>
  



  
    <span class="site-pv">
      历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇
    </span>
  
</div>










      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div class="moon-menu-item" onclick="back2bottom()">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div class="moon-menu-item" onclick="back2top()">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!-- 雪花特效 -->
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/snow.js"></script>